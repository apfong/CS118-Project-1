
------------------------------------------------------------------------------
|                            High level design                               |
------------------------------------------------------------------------------
Client: create a request object based on the command line URL argument, set appropriate host and port based on input.  Use getaddrinfo() to get the available ip's (we only take the first one).  Attempt to connect to the server using the port and ip address info in the serverAddr struct.  Upon successful connection, we start reading in data into a buffer using a while loop until all the data is read.  Depending on the status code, it will either save the file or display an error.

Server:

HTTP Message: The HTTPMessage class along with subclasses HTTPRequest and
HTTPResponse allow the client and server to make objects from HTTP messages
and also to make HTTP messages from objects. Specifically, HTTPRequest objects
can be built from input URLs or input messages, and an HTTP request message
can be built from a HTTPRequest object. HTTPResponse objects can be built from
input messages, and an HTTP response message can be built from a HTTPResponse
object.

Overall:

------------------------------------------------------------------------------
|                Problems you ran into and how you solved them               |
------------------------------------------------------------------------------
Client:  Had a problem correctly interpreting the URL passed in, and the ip
return would always say it is not found.  Turns out that the parsing method
for our HTTP Message was incorrect, and we were pointing to a temporary copy
of memory.  This meant that by the time the server ip was needed, it was 
already gone from memory.  Fixed this by saving a copy of the host as a string,
then it worked correctly.  Had a problem with the client timeout asynchronous 
thread that said it was terminated before actively being explicity called. Turns
out need to call detach on thread for it to run asynchrounously. 

Server: when forking, failed to close the newly connected client's file 
descriptor in the parent fork, causing the first message send to be received
by the parent branch. ended up refactoring the code in the parent branch to
consist soely of closing that file descriptor. Also issue with reading from
the client socket until a certain delimiter, for ex: \r\n\r\n. Worked
iteratively, communicating with a simple client that would send a message.
Hard part was understanding how to use recv to read in only a specific part of
the message. After figuring out that it is possible to use recv byte by byte,
the parsing of the incoming request was much easier.  We first implemented the
transfer using a string, and this worked fine for text based files like html.
However, it did not work for transferring images for example, so we changed
our implementation to use a vector of chars instead.

HTTP Message: Error checking was the main issue. Parsing and extracting the
data fields wasn't bad when we were expecting correct and valid HTTP requests,
but once we had to deal with bad requests, things got a little bit more
difficult, because there are so many ways a request could go wrong. Right now,
our server checks that the method was GET, and that the http version is either
1.0, 1.1, or 2.0. It sends the bad request message to any other method and
any other version number. We also check for the formatting of the requests,
so that strings not in the specified format will be rejected. We accounted
for this by adding loops to skip white space (because multiple spaces are
apparently still valid), by adding checks in a few places to make sure that
the message doesn't end prematurely or have carriage returns and new lines at
invalid places, and by creating a new member method isValid() that allows the
client and server to check whether or not an object was successfully created
from a valid http message. Also, we had to check that the method was indeed
GET, and that the version was specifically 1.0, 1.1, or 2.0.

Overall: Had to refactor our code to use a vector of char when sending the
payload of the message, as binary data is improperly interpreted when put into
strings, specifically because of the escape character '\'. This leads chars
like '\0' to be misrepresented when sending the file.


------------------------------------------------------------------------------
|                Additional instructions to build your project               |
------------------------------------------------------------------------------
Added web-server-async to Makefile

------------------------------------------------------------------------------
|                       How you tested your code and why                     |
------------------------------------------------------------------------------
Client: Made requests to different websites, tested receiving large files, both
text and image (binary) files.  To test timeout, set the timout length to a small
 value, to make sure that if time limit exceeded, would exit gracefully.  Send
invalid requests, to make sure it could handle reading errors and displaying them.

Server: Tested communication with the client to see that the header was being
properly created (headers), and transmitted. Tried to connect to it with
multiple clients and simultaneously download a large file. We saw that they
were both receiving concurrently.

HTTP Message: Gave it a few random urls to which it would create the Http
request and response. We then looked to make sure that the format matched that
of a normal http header, with proper spacing and carriage returns. Also tested
error handling by editing the requests that our clients make. We then sent out
some bad requests to our server, and made sure that our code was able to catch
that the requests were poorly formatted and therefore invalid.

Overall: 

Partial response
Partial request
Bad request and see how you handle it

------------------------------------------------------------------------------
|                 Contribution of each team member and their UID             |
------------------------------------------------------------------------------
Brandon: Client 504403364
Max: HTTPMessage 304290221
Alex: Server UID

Questions:
  What headers do we need to support for responses?
  What are we supposed to do with the hostname argument for the server?
  For status header in response, do we need to keep track of code and phrase
     separately, or is it sufficient to just have a string for both?
