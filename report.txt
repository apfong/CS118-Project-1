
------------------------------------------------------------------------------
|                            High level design                               |
------------------------------------------------------------------------------
Client: create a request object based on the command line URL argument, set appropriate host and port based on input.  Use getaddrinfo() to get the available ip's (we only take the first one).  Attempt to connect to the server using the port and ip address info in the serverAddr struct.  Upon successful connection, we start reading in data into a buffer using a while loop until all the data is read.  Depending on the status code, it will either save the file or display an error.

Server:

HTTP Message:

Overall:

------------------------------------------------------------------------------
|                Problems you ran into and how you solved them               |
------------------------------------------------------------------------------
Client:  Had a problem correctly interpreting the URL passed in, and the ip
return would always say it is not found.  Turns out that the parsing method
for our HTTP Message was incorrect, and we were pointing to a temporary copy
of memory.  This meant that by the time the server ip was needed, it was 
already gone from memory.  Fixed this by saving a copy of the host as a string,
then it worked correctly.  Had a problem with the client timeout asynchronous 
thread that said it was terminated before actively being explicity called. Turns
out need to call detach on thread for it to run asynchrounously. 

Server: when forking, failed to close the newly connected client's file 
descriptor in the parent fork, causing the first message send to be received
by the parent branch. ended up refactoring the code in the parent branch to
consist soely of closing that file descriptor. Also issue with reading from
the client socket until a certain delimiter, for ex: \r\n\r\n. Worked
iteratively, communicating with a simple client that would send a message.
Hard part was understanding how to use recv to read in only a specific part of
the message. After figuring out that it is possible to use recv byte by byte,
the parsing of the incoming request was much easier.  We first implemented the
transfer using a string, and this worked fine for text based files like html.
However, it did not work for transferring images for example, so we changed
our implementation to use a vector of chars instead.

HTTP Message:

Overall: Had to refactor our code to use a vector of char when sending the
payload of the message, as binary data is improperly interpreted when put into
strings, specifically because of the escape character '\'. This leads chars
like '\0' to be misrepresented when sending the file.


------------------------------------------------------------------------------
|                Additional instructions to build your project               |
------------------------------------------------------------------------------
None


------------------------------------------------------------------------------
|                       How you tested your code and why                     |
------------------------------------------------------------------------------
Client: Made requests to different websites, tested receiving large files, both
text and image (binary) files.  To test timeout, set the timout length to a small
 value, to make sure that if time limit exceeded, would exit gracefully.  Send
invalid requests, to make sure it could handle reading errors and displaying them.

Server: Tested communication with the client to see that the header was being
properly created (headers), and transmitted. Tried to connect to it with
multiple clients and simultaneously download a large file. We saw that they
were both receiving concurrently.

HTTP Message: Gave it a few random urls to which it would create the Http
request and response. We then looked to make sure that the format matched that
of a normal http header, with proper spacing and carriage returns

Overall:

Partial response
Partial request
Bad request and see how you handle it

------------------------------------------------------------------------------
|                 Contribution of each team member and their UID             |
------------------------------------------------------------------------------
Brandon: Client 504403364
Max: HTTPMessage UID
Alex: Server UID

Questions:
  What headers do we need to support for responses?
  What are we supposed to do with the hostname argument for the server?
  For status header in response, do we need to keep track of code and phrase
     separately, or is it sufficient to just have a string for both?
